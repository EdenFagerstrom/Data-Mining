 
 # install.packages('cccd')
 # install.packages('rgexf')
 # install.packages('BNSL')
 # install.packages('igraph')
 # install.packages('XGR')


main()
 main <- function()
 {
   library('rgexf')
   library('BNSL')
   library('igraph')
   library('cccd')
   library('class')
   hamJaccRowMatrix()
   hamJaccColMatrix
   mstGraph()
   RNGHamming()
   JaccardmstGraph()
   jaccardRNG()
   knnHammingRows()
   
   
 }
 

 # Exercise 1)
 
 # a)
 
 # Returns the matrices for question 1a
 hamJaccRowMatrix <- function(){
   US = read.csv("USPresidency.csv")
   US$Target <- NULL
   # Makes empty base matrix to be used for Question1(a)
   emptyMat <- matrix(nrow = nrow(US), ncol = nrow(US))
   
   #Assigns the Years as the Names of the columns and rows of the Base Matrix.
   colnames(emptyMat) <- US[,1]
   rownames(emptyMat) <- US[,1]
   US$Year <- NULL
   #Deep Copies the empty matrix into the two result matrices.
   hammyMat <- emptyMat
   jaccMat <- emptyMat
  
   x <- 1
   y <- 1
   # Loops Through calculating the hamming distances and Jaccard Similarities.
   while(x < nrow(emptyMat)+1){
     while(y < ncol(emptyMat)+1){
       hammyMat[x,y] <-  hammyDist(US[x,],US[y,])
       jaccMat[x,y] <- jaccDist(US[x,],US[y,])
       
       y = y + 1
     }
     x = x + 1
     y = 1
   }
   
   # Jaccard and Hamming comparisons between rows of dataset Matrices stored in list  
   hamJaccRowLis <- list(hammyMat,jaccMat)
   
   
   
 }
 
 
 
 # b)
 
 # Returns the Hamming Distance Matrix and matrix generated by jaccard measure that is obtained by comparing columns of dataset 
 hamJaccColMatrix <- function()
 {
   
   US = read.csv("USPresidency.csv")
   US$Target = NULL
   US$Year <- NULL
   colMat <- matrix(nrow = ncol(US), ncol = ncol(US))
   
   colnames(colMat) <- colnames(US)
   rownames(colMat) <- colnames(US)
   hamColMat <- colMat
   jaccColMat <- colMat
   x <- 1
   y <- 1
   # Loops Through calculating the hamming distances and Jaccard Similarities.
   while(x < nrow(colMat)+1){
     while(y < ncol(colMat)+1){
       
       hamColMat[x,y] <-  hammyDist(US[,x],US[,y])
       jaccColMat[x,y] <- jaccDist(US[,x],US[,y])
       
       y = y + 1
     }
     x = x + 1
     y = 1
   }
   # Jaccard and Hamming comparisons between columns of dataset Matrices stored in list  
   hamJaccColLis <- list(hamColMat,jaccColMat)
   
 }

 
 # c)
 
 # Returns the Mininum Spanning tree graph for the Hamming distance matrices from questions 1a and 1b 
 mstGraph <- function ()
 {
   
   q1a = hamJaccRowMatrix()
   q1b = hamJaccColMatrix()
   
   hamRows = q1a[[1]]
   hamCols =q1b[[1]]
   hamRowsGraph <- graph_from_adjacency_matrix(hamRows,mode = 'undirected', weighted = TRUE)
   hamColsGraph <- graph_from_adjacency_matrix(hamCols,mode = 'undirected', weighted = TRUE)
   
   #sets the names for the vertices
   #Sets the labels which is what Yed uses
   V(hamRowsGraph)$name <- colnames(hamRows)
   V(hamColsGraph)$name <- colnames(hamCols)
   V(hamRowsGraph)$label <- colnames(hamRows)
   E(hamRowsGraph)$label <- E(hamRowsGraph)$weight
   E(hamColsGraph)$label <- E(hamColsGraph)$weight
   
   write_graph((mst(hamRowsGraph)),'hammingRowsMST.gml',format = "gml")
   write_graph(mst(hamColsGraph),'hammingColumnsMST.gml',format = "gml")
   plot(mst(hamRowsGraph))
   plot(mst(hamColsGraph))
   
 }
mstGraph()

# Exercise 2
 
 # Returns the Relative Neighborhood graphs for the Hamming distance matrices from questions 1a and 1b 
 RNGHamming <- function()
 {
   q1a = hamJaccRowMatrix()
   q1b = hamJaccColMatrix()
   hamRows = q1a[[1]]
   hamCols = q1b[[1]] 
   rngHamRows <- rng(x=hamRows, open = FALSE, r = 1, algorithm = 'kd_tree')
   rngHamCols <- rng(x=hamCols, open = FALSE, r = 1, algorithm = 'kd_tree')
   rowMat_EL <- as.matrix(rngHamRows, matrix.type =  "edgelist")
   colMat_EL <- as.matrix(rngHamCols, matrix.type = "edgelist")
   graph_rngRows <- graph_from_edgelist(rowMat_EL, directed = FALSE)
   graph_rngCols <- graph_from_edgelist(colMat_EL, directed = FALSE)
   V(graph_rngRows)$name <- colnames(hamRows)
   V(graph_rngCols)$name <- colnames(hamCols)
   write_graph(graph_rngRows, 'hammingRowsRNG', format = "gml")
   write_graph(graph_rngCols, 'hammingColsRNG', format = "gml")
   plot(graph_rngRows)
   plot(graph_rngCols)
 }
 RNGHamming()

 
 
# Exercise 3
 
 # Returns the Minimum Spanning tree graph for the Jaccard distance matrices from questions 1a and 1b  
 JaccardmstGraph <- function ()
 {
   
   q1a = hamJaccRowMatrix()
   q1b = hamJaccColMatrix()
   
   jacRows = q1a[[2]]
   jacCols =q1b[[2]]
   jacRowsGraph <- graph_from_adjacency_matrix(jacRows,mode = 'undirected', weighted = TRUE)
   jacColsGraph <- graph_from_adjacency_matrix(jacCols,mode = 'undirected', weighted = TRUE)
   
   #sets the names for the vertices
   #Sets the labels which is what Yed uses
   V(jacRowsGraph)$name <- colnames(jacRows)
   V(jacColsGraph)$name <- colnames(jacCols)
   E(jacRowsGraph)$label <- E(jacRowsGraph)$weight
   E(jacColsGraph)$label <- E(jacColsGraph)$weight
   
   write_graph((mst(jacRowsGraph)),'jaccardRowsMST.gml',format = "gml")
   write_graph(mst(jacColsGraph),'jaccardColumnsMST.gml',format = "gml")
   plot(mst(jacRowsGraph))
   plot(mst(jacColsGraph))
   
 }
 JaccardmstGraph()
 
 
# Exercise 4
 
 # Returns the Relative Neighborhood Graph for the Jaccard distance matrices from questions 1a and 1b  
 jaccardRNG <- function()
 {
   q1a = hamJaccRowMatrix()
   q1b = hamJaccColMatrix()
   jacRows = q1a[[2]]
   jacCols = q1b[[2]] 
   rngJacRows <- rng(x=jacRows, r = 1, open = FALSE, algorithm = 'kd_tree')
   rngJacCols <- rng(x=jacCols, r = 1, open = FALSE, algorithm = 'kd_tree')
   rowMat_EL <- as.matrix(rngJacRows, matrix.type =  "edgelist")
   colMat_EL <- as.matrix(rngJacCols, matrix.type = "edgelist")
   rngJacRowsGraph <- graph_from_edgelist(rowMat_EL, directed = FALSE)
   rngJacColsGraph <- graph_from_edgelist(colMat_EL, directed = FALSE)
   V(rngJacRowsGraph)$name <- colnames(jacRows)
   V(rngJacColsGraph)$name <- colnames(jacCols)
   write_graph(rngJacRowsGraph, 'hammingRowsRNG', format = "gml")
   write_graph(rngJacColsGraph, 'hammingColsRNG', format = "gml")
   plot(rngJacRowsGraph)
   plot(rngJacColsGraph)
 }
 
 jaccardRNG()
 
 
 
 
# Exercise 5
 
 knnHammingRows <- function(){
 q1a <- hamJaccRowMatrix() 
 hammyRows <- q1a[[1]] 
 knnGraph <- nng(x = hammyRows, k = 2, algorithm = 'cover_tree')
 rowMat_EL <- as.matrix(knnGraph, matrix.type =  "edgelist")
 knnHammyGraph <- graph_from_edgelist(rowMat_EL, directed = FALSE)
 V(knnHammyGraph)$name <- colnames(hammyRows)
 write_graph(knnHammyGraph, 'hammingRowsKnn', format = "gml")
 plot(knnHammyGraph)
 }

 knnHammingRows()
 
 
# Exercise 6
 
 knnJacRows <- function(){
   q1a <- hamJaccRowMatrix() 
   jacRows <- q1a[[2]] 
   knnGraph <- nng(x = jacRows, k = 2, algorithm = 'cover_tree')
   rowMat_EL <- as.matrix(knnGraph, matrix.type =  "edgelist")
   knnJacGraph <- graph_from_edgelist(rowMat_EL, directed = FALSE)
   V(knnJacGraph)$name <- colnames(jacRows)
   write_graph(knnJacGraph, 'jaccardRowsKnn', format = "gml")
   plot(knnJacGraph)
 }
 
 knnJacRows()
 
 
# Exercise 7
 
# Based on Results of ex5(knn) and ex1c(MST)
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 # Returns the Jaccard similarities between any two binary strings
 jaccDist <- function(bin1,bin2){
   #The sum of the pairs of attributes that are both equal to 1; Amount of times both years have 1/true for the same attribute.
   intersection = sum(bin1 + bin2 == 2)
   #The number of times in which only one of the years value is 1 + the intersection.
   union = sum(bin1 + bin2 == 1) + intersection
   1 - (intersection/union)
 }
 
 # Returns hamming distance between any two binary data strings 
 hammyDist <- function(binA,binB){
   
   return(sum(binA != binB))
 }
 
 
 
 
 
 
 
 
 
 
 