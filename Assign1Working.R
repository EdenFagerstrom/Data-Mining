 
 # install.packages('cccd')
 # install.packages('rgexf')
 # install.packages('BNSL')
 # install.packages('igraph')
 # install.packages('XGR')


# Returns the Jaccard similarities between any two binary strings
jaccDist <- function(bin1,bin2){
  #The sum of the pairs of attributes that are both equal to 1; Amount of times both years have 1/true for the same attribute.
  inters = sum(bin1 + bin2 == 2)
  #The number of times in which only one of the years value is 1 + the intersection.
  join = sum(bin1 + bin2 == 1) + inters
  1 - (inters/join)
}

# Returns hamming distance between any two binary data strings 
hammyDist <- function(binA,binB){
  
  return(sum(binA != binB))
}

main()
 main <- function()
 {
   library('rgexf')
   library('BNSL')
   library('igraph')
   library('cccd')
   library('class')
   hamJaccRowMatrix()
   hamJaccColMatrix
   mstGraph()
   RNGHamming()
   JaccardmstGraph()
   jaccardRNG()
   knnHammingRows()
   knnJacRows()
   commonEdgeMstKnn()
   commonEdgesJaccardRows()
   
   
 }
 

 # Exercise 1)
 
 # a)
 
 # Returns the Hamming distance and jaccard matrices for question 1a
 hamJaccRowMatrix <- function(){
   US = read.csv("USPresidency.csv")
   US$Target <- NULL
   # Makes empty base matrix to be used for Question1(a)
   emptyMat <- matrix(nrow = nrow(US), ncol = nrow(US))
   dim(emptyMat)
   #Assigns the Years as the Names of the columns and rows of the Base Matrix.
   colnames(emptyMat) <- US[,1]
   rownames(emptyMat) <- US[,1]
   US$Year <- NULL
   #Deep Copies the empty matrix into the two result matrices.
   hammyMat <- emptyMat
   jaccMat <- emptyMat
   i <- 1
   j <- 1
   # Assigns hamming distance and jaccard distances to new matrices 
   while(i < nrow(emptyMat)+1){
     while(j < ncol(emptyMat)+1){
       hammyMat[i,j] <-  hammyDist(US[i,],US[j,])
       jaccMat[i,j] <- jaccDist(US[i,],US[j,])
       
       j = j + 1
     }
     i = i + 1
     j = 1
   }
   # Jaccard and Hamming comparisons between rows of dataset Matrices stored in list  
   hamJaccRowLis <- list(hammyMat,jaccMat)
   hamJaccRowLis
 }
 hamJaccRowMatrix()
 
 
 # b)
 
 # Returns the Hamming Distance Matrix and matrix generated by jaccard measure that
 # is obtained by comparing columns of dataset 
 hamJaccColMatrix <- function()
 {
   US = read.csv("USPresidency.csv")
   US$Target = NULL
   US$Year <- NULL
   colMat <- matrix(nrow = ncol(US), ncol = ncol(US))
   
   colnames(colMat) <- colnames(US)
   rownames(colMat) <- colnames(US)
   hamColMat <- colMat
   jaccColMat <- colMat
   x <- 1
   y <- 1
   
   # Assigns hamming distance and jaccard distances to new matrices 
   while(x < nrow(colMat)+1){
     while(y < ncol(colMat)+1){
       
       hamColMat[x,y] <-  hammyDist(US[,x],US[,y])
       jaccColMat[x,y] <- jaccDist(US[,x],US[,y])
       
       y = y + 1
     }
     x = x + 1
     y = 1
   }
   write.csv(hamColMat, "HammingColsDistanceMatrix1.csv")
   write.csv(jaccColMat, "JaccardColsDistanceMatrix1.csv")
   
   # Jaccard and Hamming Matrices stored in list  
   hamJaccColLis <- list(hamColMat,jaccColMat)
   hamJaccColLis
   
 }
 
 
 # c)
 
 # Returns the Mininum Spanning tree graph for the Hamming distance matrices 
 # from questions 1a and 1b 
 mstGraph <- function ()
 {
   
   q1a = hamJaccRowMatrix()
   q1b = hamJaccColMatrix()
   
   hamRows = q1a[[1]]
   hamCols =q1b[[1]]
   hamRowsGraph <- graph_from_adjacency_matrix(hamRows,mode = 'undirected', weighted = TRUE)
   hamColsGraph <- graph_from_adjacency_matrix(hamCols,mode = 'undirected', weighted = TRUE)
   
   #Sets the labels and edge weights which will be displayed in yEd 
   V(hamRowsGraph)$label <- colnames(hamRows)
   V(hamColsGraph)$label <- colnames(hamCols)
   E(hamRowsGraph)$label <- E(hamRowsGraph)$weight
   E(hamColsGraph)$label <- E(hamColsGraph)$weight
   
   # writes graph to gml file to be displayed in yEd graph editor
   write_graph((mst(hamRowsGraph)),'hammingRowsMST.gml',format = "gml")
   write_graph(mst(hamColsGraph),'hammingColumnsMST.gml',format = "gml")
   plot(mst(hamRowsGraph))
   plot(mst(hamColsGraph))
   
 }


# Exercise 2
 
 # Returns the Relative Neighborhood graphs for the Hamming distance matrices 
 # from questions 1a and 1b 
 RNGHamming <- function()
 {
   q1a = hamJaccRowMatrix()
   q1b = hamJaccColMatrix()
   hamRows = q1a[[1]]
   hamCols = q1b[[1]] 
   rngHamRows <- rng(dx=hamRows, open = FALSE, r = 1, algorithm = 'cover_tree')
   rngHamCols <- rng(dx=hamCols, open = FALSE, r = 1, algorithm = 'cover_tree')
   
   # sets graphs to undirected
   rngHamRows <- as.undirected(rngHamRows)
   rngHamCols <- as.undirected(rngHamCols)
   
   #Sets the labels which will be displayed in yEd 
   E(rngHamRows)$weight <- apply(get.edges(rngHamRows,1:ecount(rngHamRows)),1,function(x)hamRows[x[1],x[2]])
   E(rngHamCols)$weight <- apply(get.edges(rngHamCols,1:ecount(rngHamCols)),1,function(x)hamCols[x[1],x[2]])
   E(rngHamRows)$label <- E(rngHamRows)$weight
   E(rngHamCols)$label <- E(rngHamCols)$weight
   V(rngHamRows)$label <- colnames(hamRows)
   V(rngHamCols)$label <- colnames(hamCols)
   
   # writes graph to gml file to be displayed in yEd graph editor
   write_graph(rngHamRows, 'hammingRowsRNG.gml', format = "gml")
   write_graph(rngHamCols, 'hammingColsRNG.gml', format = "gml")
   plot(rngHamRows)
   plot(rngHamCols)
 }
 
 
 
# Exercise 3
 
 # Returns the Minimum Spanning tree graph for the Jaccard distance matrices 
 # from questions 1a and 1b  
 JaccardmstGraph <- function ()
 {
   
   q1a = hamJaccRowMatrix()
   q1b = hamJaccColMatrix()
   
   jacRows = q1a[[2]]
   jacCols =q1b[[2]]
   jacRowsGraph <- graph_from_adjacency_matrix(jacRows,mode = 'undirected', weighted = TRUE)
   jacColsGraph <- graph_from_adjacency_matrix(jacCols,mode = 'undirected', weighted = TRUE)
   
   #Sets the vertice labels and edge weights which will be displayed in yEd 
   V(jacRowsGraph)$label <- colnames(jacRows)
   V(jacColsGraph)$label <- colnames(jacCols)
   E(jacRowsGraph)$label <- E(jacRowsGraph)$weight
   E(jacColsGraph)$label <- E(jacColsGraph)$weight
   
   # writes graph to gml file to be displayed in yEd graph editor
   write_graph((mst(jacRowsGraph)),'jaccardRowsMST.gml',format = "gml")
   write_graph(mst(jacColsGraph),'jaccardColumnsMST.gml',format = "gml")
   
   plot(mst(jacRowsGraph))
   plot(mst(jacColsGraph))
   
 }
 
 
 
# Exercise 4
 
 # Returns the Relative Neighborhood Graph for the Jaccard distance matrices
 # from questions 1a and 1b  
 jaccardRNG <- function()
 {
   q1a = hamJaccRowMatrix()
   q1b = hamJaccColMatrix()
   jacRows = q1a[[2]]
   jacCols = q1b[[2]] 
   rngJacRows <- rng(dx=jacRows, r = 1, open = FALSE, algorithm = 'cover_tree')
   rngJacCols <- rng(dx=jacCols, r = 1, open = FALSE, algorithm = 'cover_tree')
   
   # sets graphs to undirected
   rngjacRows <- as.undirected(rngJacRows)
   rngJacCols <- as.undirected(rngJacCols)
   
   #Sets the vertice labels which will be displayed on the graph in yEd 
   E(rngJacRows)$weight <- apply(get.edges(rngJacRows,1:ecount(rngJacRows)),1,function(x)jacRows[x[1],x[2]])
   E(rngJacCols)$weight <- apply(get.edges(rngJacCols,1:ecount(rngJacCols)),1,function(x)jacCols[x[1],x[2]])
   E(rngJacRows)$label <- round(E(rngJacRows)$weight, 3)
   E(rngJacCols)$label <- round(E(rngJacCols)$weight, 3)
   V(rngJacRows)$label <- colnames(jacRows)
   V(rngJacCols)$label <- colnames(jacCols)
   
   # writes graph to gml file to be displayed in yEd graph editor
   write_graph(rngJacRows, 'jaccardRowsRNG.gml', format = "gml")
   write_graph(rngJacCols, 'jaccardColsRNG.gml', format = "gml")
   plot(rngJacRows)
   plot(rngJacCols)
 }
 
 
 
 
 
 
# Exercise 5
 # Returns the knn graph with k=2 for the Hamming distance matrix between all pairs 
 # of elections of the US Presidency Dataset
 knnHammingRows <- function(){
 q1a <- hamJaccRowMatrix() 
 hammyRows <- q1a[[1]] 
 knnGraphHam <- nng(dx = hammyRows, k = 2, algorithm = 'cover_tree')
 # sets graph to an undirected graph
 knnGraphHam <- as.undirected(knnGraphHam)

 # sets edge and vertice lables to be used in yEd graph editor
 E(knnGraphHam)$weight <- apply(get.edges(knnGraphHam,1:ecount(knnGraphHam)),1,function(x)hammyRows[x[1],x[2]])
 E(knnGraphHam)$label <- E(knnGraphHam)$weight
 V(knnGraphHam)$label <- colnames(hammyRows)
 
 # writes graph to gml file to be displayed in yEd graph editor
 write_graph(knnGraphHam, 'hammingRowsKnn.gml', format = "gml")
 plot(knnGraphHam)
 }


 
 
# Exercise 6
 # Returns the knn graph with k=2 for the Jaccard distance matrix between all pairs 
 # of elections of the US Presidency Dataset
 knnJacRows <- function(){
   q1a <- hamJaccRowMatrix() 
   jacRows <- q1a[[2]] 
   knnGraphJac <- nng(dx = jacRows, k = 2, algorithm = 'cover_tree')
   
   # set to undirected graph
   knnGraphJac <- as.undirected(knnGraphJac)
   
   # writes graph to gml file to be displayed in yEd graph editor
   E(knnGraphJac)$weight <- apply(get.edges(knnGraphJac,1:ecount(knnGraphJac)),1,function(x)jacRows[x[1],x[2]])
   E(knnGraphJac)$label <- round(E(knnGraphJac)$weight, 3)
   V(knnGraphJac)$label <- colnames(jacRows)
   
   # writes graph to gml file to be displayed in yEd graph editor
   write_graph(knnGraphJac, 'jaccardRowsKnn.gml', format = "gml")
   plot(knnGraphJac)
 }
 
 
 
 
# Exercise 7
 
# Returns graph with common edges from q1c(mst) and q5(knn)
 commonEdgeMstKnn <- function()
 {
   q1a <- hamJaccRowMatrix() 
   hammyRows <- q1a[[1]] 
   #knn code
   knnGraphHam <- nng(dx = hammyRows, k = 2, algorithm = 'cover_tree')
   knnGraphHam <- as.undirected(knnGraphHam)
   V(knnGraphHam)$name <- colnames(hammyRows)
   V(knnGraphHam)$label <- colnames(hammyRows)
   
   #mst code
   hamRowsGraph <- graph_from_adjacency_matrix(hammyRows,mode = 'undirected', weighted = TRUE)
   V(hamRowsGraph)$name <- colnames(hammyRows)
   V(hamRowsGraph)$label <- colnames(hammyRows)
   E(hamRowsGraph)$label <- E(hamRowsGraph)$weight
   E(hamRowsGraph)$name <- E(hamRowsGraph)$weight
   hamRowsGraphMST <- mst(hamRowsGraph)
   
   # stores common edges between graphs in new variable
   commonEdges <- intersection(knnGraphHam, hamRowsGraphMST, byname = "auto" )
   E(commonEdges)$weight <- apply(get.edges(commonEdges,1:ecount(commonEdges)),1,function(x)hammyRows[x[1],x[2]])
   E(commonEdges)$label <- E(commonEdges)$weight
   V(commonEdges)$name <- colnames(hammyRows)
   V(commonEdges)$label <- colnames(hammyRows)
   
   write_graph(commonEdges, 'commonEdgeMstKnn_EX7.gml', format = "gml")
   plot(commonEdges)
 }



 
 
 # Exercise 8
 commonEdgesJaccardRows <- function()
   {
   q1a <- hamJaccRowMatrix() 
   jacRows <- q1a[[2]] 
   
   # knn graph retrieval
   knnGraphJac <- nng(dx = jacRows, k = 2, algorithm = 'cover_tree')
   # set to undirected graph
   knnGraphJac <- as.undirected(knnGraphJac)
   V(knnGraphJac)$label <- colnames(jacRows)
   V(knnGraphJac)$name <- colnames(jacRows)
   
   # mst graph retrieval
   jacRowsGraph <- graph_from_adjacency_matrix(jacRows,mode = 'undirected', weighted = TRUE)
   #Sets the vertices labels and edge weights which will be displayed in yEd 
   V(jacRowsGraph)$label <- colnames(jacRows)
   V(jacRowsGraph)$name <- colnames(jacRows)
   E(jacRowsGraph)$label <- round(E(jacRowsGraph)$weight, 3)
   E(jacRowsGraph)$name <- round(E(jacRowsGraph)$weight, 3)
   jacRowsGraphMst <- mst(jacRowsGraph)
  
   # stores common edges between two graphs in new variable
   commonEdges <- intersection(knnGraphJac, jacRowsGraphMst, byname = "auto" )
   E(commonEdges)$weight <- apply(get.edges(commonEdges,1:ecount(commonEdges)),1,function(x)jacRows[x[1],x[2]])
   E(commonEdges)$label <- round(E(commonEdges)$weight, 3)
   V(commonEdges)$name <- colnames(hammyRows)
   V(commonEdges)$label <- colnames(hammyRows)
   write_graph(commonEdges, 'commonEdgeMstKnn_EX8.gml', format = "gml")
   plot(commonEdges)
   
   }
  

 
 
 
 
 
 
 
 
 
 
  
 
 
 
 
 
 